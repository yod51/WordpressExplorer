<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WordPress Media Explorer</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f0f2f5;
      color: #1e1e1e;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      background-color: #fff;
      padding: 15px 20px;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    h1 {
      margin: 0 0 10px 0;
      font-size: 24px;
      color: #23282d;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .input-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    input,
    select,
    button {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    button {
      background-color: #2271b1;
      color: white;
      cursor: pointer;
      border: none;
    }

    button:hover {
      background-color: #135e96;
    }

    .media-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .media-item {
      background-color: #fff;
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      position: relative;
    }

    .media-preview {
      height: 150px;
      background-color: #f1f1f1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .media-preview img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .media-info {
      padding: 10px;
      font-size: 14px;
    }

    .media-title {
      margin: 0 0 5px 0;
      font-weight: bold;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .media-meta {
      color: #666;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .media-actions {
      margin-top: 10px;
      display: flex;
      gap: 5px;
    }

    .media-actions button {
      flex: 1;
      font-size: 12px;
      padding: 5px;
    }

    .list-view {
      width: 100%;
      border-collapse: collapse;
      background-color: #fff;
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .list-view th,
    .list-view td {
      padding: 12px 15px;
      text-align: left;
      border-bottom: 1px solid #f1f1f1;
    }

    .list-view th {
      background-color: #f9f9f9;
      font-weight: 600;
      color: #23282d;
      cursor: pointer;
    }

    .list-view th:hover {
      background-color: #f1f1f1;
    }

    .list-view tr:hover {
      background-color: #f9f9f9;
    }

    .pagination {
      display: flex;
      justify-content: center;
      margin-top: 20px;
      gap: 10px;
    }

    .page-info {
      display: flex;
      align-items: center;
      margin-right: auto;
      font-size: 14px;
      color: #555;
    }

    .loader {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: #2271b1;
      animation: spin 1s linear infinite;
      margin-right: 10px;
      display: none;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .view-toggle {
      display: flex;
      gap: 5px;
    }

    .view-toggle button {
      padding: 5px 10px;
    }

    .active-view {
      background-color: #135e96;
    }

    .hidden {
      display: none;
    }

    #error-message {
      color: #d63638;
      background-color: #ffecec;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 15px;
      display: none;
    }

    .file-icon {
      font-size: 48px;
      color: #2271b1;
    }

    .preview-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      display: none;
    }

    /* Add to your existing CSS */
    .retry-image {
      min-height: 40px;
      min-width: 40px;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="38" height="38" viewBox="0 0 38 38"><g fill="none" fill-rule="evenodd"><g transform="translate(1 1)" stroke-width="2"><circle stroke-opacity=".5" cx="18" cy="18" r="18"/><path d="M36 18c0-9.94-8.06-18-18-18" stroke="%232271b1"><animateTransform attributeName="transform" type="rotate" from="0 18 18" to="360 18 18" dur="1s" repeatCount="indefinite"/></path></g></g></svg>');
      background-position: center;
      background-repeat: no-repeat;
      background-size: 24px;
    }

    .retry-image[src^="data:image/gif;base64"] {
      /* Show loading spinner only when image hasn't loaded yet */
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="38" height="38" viewBox="0 0 38 38"><g fill="none" fill-rule="evenodd"><g transform="translate(1 1)" stroke-width="2"><circle stroke-opacity=".5" cx="18" cy="18" r="18"/><path d="M36 18c0-9.94-8.06-18-18-18" stroke="%232271b1"><animateTransform attributeName="transform" type="rotate" from="0 18 18" to="360 18 18" dur="1s" repeatCount="indefinite"/></path></g></g></svg>');
    }

    /* Update these styles in the <style> section */
    .preview-content {
      max-width: 90%;
      max-height: 90vh;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: white;
      padding: 10px;
      border-radius: 4px;
    }

    .preview-content img {
      max-width: 100%;
      max-height: 80vh;
      object-fit: contain;
      display: block;
    }

    .preview-content video,
    .preview-content audio {
      max-width: 100%;
      max-height: 90vh;
      background-color: #fff;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
    }

    .close-preview {
      position: absolute;
      top: -40px;
      right: 0;
      background-color: transparent;
      color: white;
      border: none;
      font-size: 24px;
      cursor: pointer;
    }

    .proxy-note {
      margin-top: 10px;
      padding: 10px;
      background-color: #fff8e5;
      border-left: 4px solid #ffb900;
      margin-bottom: 20px;
    }

    #proxy-selector {
      margin-left: 10px;
    }

    .list-preview {
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 10px;
      overflow: hidden;
      background-color: #f1f1f1;
    }

    .list-preview img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .list-view td:first-child {
      display: flex;
      align-items: center;
    }

    .cors-options {
      background-color: #e9f5fe;
      border-left: 4px solid #4a9dea;
      padding: 15px;
      margin-top: 15px;
      border-radius: 4px;
    }

    .advanced-settings {
      margin-top: 10px;
    }

    .settings-toggle {
      color: #2271b1;
      text-decoration: underline;
      cursor: pointer;
    }

    .version-footer {
      margin-top: 40px;
      padding-top: 15px;
      color: #666;
      font-size: 12px;
      text-align: center;
    }

    .version-footer hr {
      border: 0;
      height: 1px;
      background-color: #ddd;
      margin-bottom: 15px;
    }

    .version-footer p {
      margin: 0;
    }

    #predefined-sites {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      width: 100%;
      margin-bottom: 10px;
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>WordPress Media Explorer</h1>
      <div id="error-message"></div>

      <div class="controls">
        <div class="input-group">
          <select id="predefined-sites">
            <option value="manual">Select Website</option>
            <option value="https://moviz.co.il">Moviz</option>
            <option value="https://lev.co.il">Lev</option>
          </select>
        </div>

        <!-- Modify your existing site-url input group to have an ID so we can hide/show it -->
        <div class="input-group" id="manual-url-input">
          <input type="text" id="site-url" placeholder="WordPress Site URL" />
          <select id="proxy-selector">
            <option value="noproxy">No Proxy (Direct)</option>
            <option value="allorigins">All Origins Proxy</option>
            <option value="cors-anywhere">CORS Anywhere Proxy</option>
          </select>
          <button id="connect-btn">Connect</button>
        </div>
        <script>updateProxyType()</script>

        <div class="input-group" id="search-controls" style="display: none;">
          <input type="text" id="search-input" placeholder="Search media..." />
          <select id="media-type">
            <option value="">All Types</option>
            <option value="image">Images</option>
            <option value="video">Videos</option>
            <option value="audio">Audio</option>
            <option value="application">Documents</option>
          </select>
          <select id="sort-by">
            <option value="date">Date</option>
            <option value="title">Title</option>
            <option value="id">ID</option>
          </select>
          <select id="sort-order">
            <option value="desc">Descending</option>
            <option value="asc">Ascending</option>
          </select>
          <label for="per-page">Items per page:</label>
          <input type="number" id="per-page" min="1" max="100" value="10" style="width: 60px;">
          <div class="view-toggle">
            <button id="grid-view-btn" class="active-view">Grid</button>
            <button id="list-view-btn">List</button>
          </div>
        </div>
      </div>

      <div class="proxy-note">
        <strong>Note:</strong> If you're experiencing CORS errors, try using a different proxy or select "No Proxy" for
        WordPress sites that have CORS properly configured.
      </div>

      <div class="cors-options" id="cors-options" style="display: none;">
        <h3>CORS Solutions</h3>
        <p>You're using direct access mode. If you encounter CORS errors, try these solutions:</p>
        <ul>
          <li>Try appending "/wp-json/" to your site URL - some WordPress sites use different REST API endpoints</li>
          <li>Enable the REST API endpoints in your WordPress settings (if you control the site)</li>
          <li>Install a CORS-enabling plugin on your WordPress site (if you control the site)</li>
          <li>Use the "jsonp" mode for compatible WordPress sites (limited functionality)</li>
        </ul>
        <div class="advanced-settings">
          <span class="settings-toggle" id="advanced-toggle">Show Advanced Settings</span>
          <div id="advanced-settings" style="display: none; margin-top: 10px;">
            <label>
              <input type="checkbox" id="use-jsonp"> Try JSONP mode (only works with some WordPress versions)
            </label>
            <br>
            <label>
              <input type="checkbox" id="use-credentials"> Include credentials (cookies)
            </label>
            <br>
            <label>
              <input type="text" id="custom-api-path" placeholder="Custom API path (e.g., /wp-json/wp/v2)">
            </label>
          </div>
        </div>
      </div>
    </header>

    <div id="loader" class="loader"></div>
    <div id="page-info" class="page-info"></div>

    <div id="media-grid" class="media-grid"></div>
    <table id="media-list" class="list-view" style="display: none;">
      <thead>
        <tr>
          <th width="40%">Title</th>
          <th width="15%">Type</th>
          <th width="15%">Date</th>
          <th width="10%">Size</th>
          <th width="20%">Actions</th>
        </tr>
      </thead>
      <tbody id="list-body"></tbody>
    </table>

    <div class="pagination">
      <button id="prev-page" disabled>← Previous</button>
      <button id="next-page" disabled>Next →</button>
    </div>

    <div id="preview-modal" class="preview-modal">
      <div class="preview-content">
        <button class="close-preview">&times;</button>
        <div id="preview-container"></div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      // State
      const state = {
        siteUrl: '',
        mediaItems: [],
        totalItems: 0,
        totalPages: 0,
        currentPage: 1,
        perPage: 10,
        search: '',
        mediaType: '',
        sortBy: 'date',
        sortOrder: 'desc',
        viewMode: 'grid',
        isLoading: false,
        proxyType: 'noproxy',
        useJsonp: false,
        useCredentials: false,
        customApiPath: '',
        failedAttempts: 0,
        fallbackMode: false
      };

      // Proxy URLs
      const PROXY_URLS = {
        'cors-anywhere': 'https://cors-anywhere.herokuapp.com/',
        'allorigins': 'https://api.allorigins.win/raw?url='
      };

      // Elements
      const siteUrlInput = document.getElementById('site-url');
      const proxySelector = document.getElementById('proxy-selector');
      const connectBtn = document.getElementById('connect-btn');
      const searchControls = document.getElementById('search-controls');
      const searchInput = document.getElementById('search-input');
      const mediaTypeSelect = document.getElementById('media-type');
      const sortBySelect = document.getElementById('sort-by');
      const sortOrderSelect = document.getElementById('sort-order');
      const perPageInput = document.getElementById('per-page');
      const mediaGrid = document.getElementById('media-grid');
      const mediaList = document.getElementById('media-list');
      const listBody = document.getElementById('list-body');
      const prevPageBtn = document.getElementById('prev-page');
      const nextPageBtn = document.getElementById('next-page');
      const gridViewBtn = document.getElementById('grid-view-btn');
      const listViewBtn = document.getElementById('list-view-btn');
      const loader = document.getElementById('loader');
      const pageInfo = document.getElementById('page-info');
      const errorMessage = document.getElementById('error-message');
      const previewModal = document.getElementById('preview-modal');
      const previewContainer = document.getElementById('preview-container');
      const closePreview = document.querySelector('.close-preview');
      const corsOptions = document.getElementById('cors-options');
      const advancedToggle = document.getElementById('advanced-toggle');
      const advancedSettings = document.getElementById('advanced-settings');
      const useJsonpCheckbox = document.getElementById('use-jsonp');
      const useCredentialsCheckbox = document.getElementById('use-credentials');
      const customApiPathInput = document.getElementById('custom-api-path');
      const predefinedSites = document.getElementById('predefined-sites');
      const manualUrlInput = document.getElementById('manual-url-input');

      // Add event listener for predefined sites dropdown
      predefinedSites.addEventListener('change', function () {
        const selectedValue = this.value;

        if (selectedValue === 'manual') {
          // Show manual input option
          manualUrlInput.style.display = 'flex';
          siteUrlInput.value = '';
          siteUrlInput.focus();
        } else if (selectedValue) {
          // A predefined site was selected
          manualUrlInput.style.display = 'none';
          siteUrlInput.value = selectedValue;

          // Auto-connect to the selected site
          state.siteUrl = selectedValue.endsWith('/') ? selectedValue.slice(0, -1) : selectedValue;
          state.currentPage = 1;
          state.failedAttempts = 0;
          state.fallbackMode = false;
          fetchMedia();
          searchControls.style.display = 'flex';
        } else {
          // Default option - show manual input
          manualUrlInput.style.display = 'flex';
        }
      });

      // Event Listeners
      connectBtn.addEventListener('click', connectToSite);
      proxySelector.addEventListener('change', updateProxyType);
      searchInput.addEventListener('input', debounce(updateSearch, 500));
      mediaTypeSelect.addEventListener('change', updateFilters);
      sortBySelect.addEventListener('change', updateFilters);
      sortOrderSelect.addEventListener('change', updateFilters);
      perPageInput.addEventListener('change', updatePerPage);
      prevPageBtn.addEventListener('click', goToPreviousPage);
      nextPageBtn.addEventListener('click', goToNextPage);
      gridViewBtn.addEventListener('click', () => switchView('grid'));
      listViewBtn.addEventListener('click', () => switchView('list'));
      closePreview.addEventListener('click', closePreviewModal);
      advancedToggle.addEventListener('click', toggleAdvancedSettings);
      useJsonpCheckbox.addEventListener('change', () => { state.useJsonp = useJsonpCheckbox.checked; });
      useCredentialsCheckbox.addEventListener('change', () => { state.useCredentials = useCredentialsCheckbox.checked; });
      customApiPathInput.addEventListener('input', () => { state.customApiPath = customApiPathInput.value.trim(); });
      // Add this event listener to handle Enter key presses in the URL input field
      siteUrlInput.addEventListener('keydown', function (event) {
        // Check if Enter key was pressed
        if (event.key === 'Enter') {
          // Prevent default form submission behavior
          event.preventDefault();

          // Trigger the same action as clicking the connect button
          connectBtn.click();
        }
      });

      function toggleAdvancedSettings() {
        if (advancedSettings.style.display === 'none') {
          advancedSettings.style.display = 'block';
          advancedToggle.textContent = 'Hide Advanced Settings';
        } else {
          advancedSettings.style.display = 'none';
          advancedToggle.textContent = 'Show Advanced Settings';
        }
      }

      // Update proxy type
      function updateProxyType() {
        state.proxyType = proxySelector.value;
        if (state.proxyType === 'noproxy') {
          corsOptions.style.display = 'block';
        } else {
          corsOptions.style.display = 'none';
        }
      }

      // Update per page
      function updatePerPage() {
        const value = parseInt(perPageInput.value);
        if (value > 0 && value <= 100) {
          state.perPage = value;
          state.currentPage = 1;
          fetchMedia();
        } else {
          perPageInput.value = state.perPage;
        }
      }

      // Get proxied URL
      function getProxiedUrl(url) {
        if (state.proxyType === 'noproxy') {
          return url;
        } else if (state.proxyType === 'allorigins') {
          return PROXY_URLS.allorigins + encodeURIComponent(url);
        } else {
          return PROXY_URLS['cors-anywhere'] + url;
        }
      }

      // Connect to WordPress site
      function connectToSite() {
        let url = siteUrlInput.value.trim();
        if (!url) {
          showError('Please enter a WordPress site URL');
          return;
        }

        // Add protocol if missing
        if (!/^https?:\/\//i.test(url)) {
          url = 'https://' + url;
        }

        state.siteUrl = url.endsWith('/') ? url.slice(0, -1) : url;
        state.currentPage = 1;
        state.failedAttempts = 0;
        state.fallbackMode = false;
        fetchMedia();
        searchControls.style.display = 'flex';
      }

      // Fetch media from WordPress REST API
      function fetchMedia() {
        setLoading(true);
        hideError();

        // Build API URL based on settings
        let apiPath;
        if (state.customApiPath) {
          apiPath = state.customApiPath;
        } else {
          apiPath = '/wp-json/wp/v2/media';
        }

        let apiUrl = `${state.siteUrl}${apiPath}?per_page=${state.perPage}&page=${state.currentPage}`;

        // Add search params
        if (state.search) {
          apiUrl += `&search=${encodeURIComponent(state.search)}`;
        }

        // Add media type filter
        if (state.mediaType) {
          apiUrl += `&media_type=${encodeURIComponent(state.mediaType)}`;
        }

        // Add sorting
        apiUrl += `&orderby=${state.sortBy}&order=${state.sortOrder}`;

        // Apply proxy if needed
        const fetchUrl = getProxiedUrl(apiUrl);

        // If using JSONP, handle that separately
        if (state.proxyType === 'noproxy' && state.useJsonp) {
          fetchWithJsonp(apiUrl);
          return;
        }

        // Options for fetch
        const fetchOptions = {
          method: 'GET',
          headers: {
            'Accept': 'application/json'
          }
        };

        if (state.proxyType === 'cors-anywhere') {
          fetchOptions.headers['X-Requested-With'] = 'XMLHttpRequest';
        }

        if (state.proxyType === 'noproxy' && state.useCredentials) {
          fetchOptions.credentials = 'include';
        }

        // Fetch data
        fetch(fetchUrl, fetchOptions)
          .then(response => {
            if (!response.ok) {
              throw new Error(`Error ${response.status}: ${response.statusText}`);
            }

            // Get total values from headers
            let totalItems = 0;
            let totalPages = 0;

            // Try to get pagination headers
            const wpTotal = response.headers.get('X-WP-Total');
            const wpTotalPages = response.headers.get('X-WP-TotalPages');

            if (wpTotal && wpTotalPages) {
              totalItems = parseInt(wpTotal);
              totalPages = parseInt(wpTotalPages);
            }

            state.totalItems = totalItems;
            state.totalPages = totalPages;

            return response.json();
          })
          .then(data => {
            if (!Array.isArray(data)) {
              if (state.proxyType === 'noproxy' && !state.fallbackMode) {
                // Try alternate API paths for WordPress
                tryAlternativeEndpoints();
                return;
              }
              throw new Error('Invalid response format. Expected an array of media items.');
            }

            state.mediaItems = data;

            // If we couldn't get pagination info from headers, estimate it
            if (state.totalItems === 0 && data.length > 0) {
              state.totalItems = data.length * 10; // Rough estimate
              state.totalPages = 10; // Rough estimate
            }

            renderMedia();
            updatePagination();
            setLoading(false);
          })
          .catch(error => {
            console.error('Fetch error:', error);

            if (state.proxyType === 'noproxy' && !state.fallbackMode) {
              // Try with alternate strategies
              handleCorsError();
            } else {
              showError(`Failed to fetch media: ${error.message}. Try a different proxy or check the URL.`);
              setLoading(false);
            }
          });
      }

      // Handle CORS errors with fallback strategies
      function handleCorsError() {
        state.failedAttempts++;

        if (state.failedAttempts === 1) {
          // First try: Attempt with a different API endpoint pattern
          state.customApiPath = '/index.php/wp-json/wp/v2/media';
          console.log('Trying alternate endpoint:', state.customApiPath);
          fetchMedia();
        } else if (state.failedAttempts === 2) {
          // Second try: Attempt with a different API endpoint pattern
          state.customApiPath = '/wp-json/v2/media';
          console.log('Trying alternate endpoint:', state.customApiPath);
          fetchMedia();
        } else if (state.failedAttempts === 3) {
          // Third try: Switch to JSONP as a fallback
          state.useJsonp = true;
          useJsonpCheckbox.checked = true;
          console.log('Switching to JSONP mode');
          fetchMedia();
        } else {
          // Final fallback: Switch to proxy
          state.fallbackMode = true;
          state.proxyType = 'allorigins';
          proxySelector.value = 'allorigins';
          corsOptions.style.display = 'none';
          console.log('Switching to proxy mode:', state.proxyType);

          showError('Direct access failed. Trying with the All Origins proxy instead.');
          fetchMedia();
        }
      }

      // Try alternative REST API endpoints
      function tryAlternativeEndpoints() {
        const alternativePatterns = [
          '/wp-json/wp/v2/media',
          '/index.php/wp-json/wp/v2/media',
          '/api/wp-json/wp/v2/media',
          '/wp-json/v2/media'
        ];

        if (state.failedAttempts < alternativePatterns.length) {
          state.customApiPath = alternativePatterns[state.failedAttempts];
          state.failedAttempts++;
          console.log('Trying alternative endpoint:', state.customApiPath);
          fetchMedia();
        } else {
          // Try JSONP or switch to proxy as last resort
          handleCorsError();
        }
      }

      // Fetch with JSONP (for older WordPress sites or where CORS is an issue)
      function fetchWithJsonp(url) {
        // Remove any existing JSONP scripts
        const oldScripts = document.querySelectorAll('script.jsonp-script');
        oldScripts.forEach(script => script.remove());

        // Add callback parameter
        const callbackName = 'wordpressMediaCallback' + Date.now();
        const jsonpUrl = `${url}&callback=${callbackName}`;

        // Create global callback function
        window[callbackName] = function (data) {
          // Clean up
          delete window[callbackName];
          document.querySelector(`script[src*="${callbackName}"]`).remove();

          if (!Array.isArray(data)) {
            showError('Invalid response format from JSONP. Expected an array of media items.');
            setLoading(false);
            return;
          }

          state.mediaItems = data;

          // Estimate pagination since headers aren't available in JSONP
          if (data.length > 0) {
            state.totalItems = data.length * 10; // Rough estimate
            state.totalPages = 10; // Rough estimate
          } else {
            state.totalItems = 0;
            state.totalPages = 0;
          }

          renderMedia();
          updatePagination();
          setLoading(false);
        };

        // Create script tag to make the request
        const script = document.createElement('script');
        script.src = jsonpUrl;
        script.className = 'jsonp-script';
        script.onerror = function () {
          showError('JSONP request failed. Try a different access method or check the URL.');
          setLoading(false);
          // Clean up
          delete window[callbackName];
          script.remove();

          // Fallback to proxy
          if (!state.fallbackMode) {
            state.fallbackMode = true;
            state.proxyType = 'allorigins';
            proxySelector.value = 'allorigins';
            corsOptions.style.display = 'none';
            console.log('JSONP failed. Switching to proxy mode:', state.proxyType);

            showError('JSONP access failed. Trying with the All Origins proxy instead.');
            fetchMedia();
          }
        };

        document.body.appendChild(script);

        // Set timeout in case the JSONP request gets stuck
        setTimeout(function () {
          if (window[callbackName]) {
            showError('JSONP request timed out. Try a different access method.');
            setLoading(false);
            // Clean up
            delete window[callbackName];
            script.remove();

            // Fallback to proxy
            if (!state.fallbackMode) {
              state.fallbackMode = true;
              state.proxyType = 'allorigins';
              proxySelector.value = 'allorigins';
              corsOptions.style.display = 'none';
              console.log('JSONP timed out. Switching to proxy mode:', state.proxyType);

              showError('JSONP access timed out. Trying with the All Origins proxy instead.');
              fetchMedia();
            }
          }
        }, 10000); // 10 second timeout
      }

      // Detect if a URL is directly accessible (no CORS issues)
      function testDirectAccess(url) {
        return new Promise((resolve, reject) => {
          fetch(url, {
            method: 'HEAD',
            mode: 'no-cors'
          }).then(() => {
            // This doesn't guarantee CORS access, just reachability
            resolve(true);
          }).catch(() => {
            resolve(false);
          });
        });
      }

      // Render media items based on view mode
      function renderMedia() {
        if (state.viewMode === 'grid') {
          renderGridView();
        } else {
          renderListView();
        }

        // Update page info
        if (state.totalItems > 0) {
          const startItem = (state.currentPage - 1) * state.perPage + 1;
          const endItem = Math.min(startItem + state.mediaItems.length - 1, state.totalItems);
          pageInfo.textContent = `Showing ${startItem}-${endItem} of ${state.totalItems} items`;
        } else {
          pageInfo.textContent = `Showing ${state.mediaItems.length} items`;
        }
      }

      // Render grid view
      function renderGridView() {
        mediaGrid.innerHTML = '';

        if (state.mediaItems.length === 0) {
          mediaGrid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 30px;">No media items found</div>';
          return;
        }

        state.mediaItems.forEach(item => {
          const mediaItem = document.createElement('div');
          mediaItem.className = 'media-item';

          // Use direct URLs for preview and download
          const sourceUrl = item.source_url;
          let thumbnailUrl = sourceUrl;

          // Try to get thumbnail if available
          if (item.media_details && item.media_details.sizes && item.media_details.sizes.thumbnail) {
            thumbnailUrl = item.media_details.sizes.thumbnail.source_url;
          }

          // Handle URL for cross-origin images
          if (state.proxyType !== 'noproxy') {
            // Use the proxy for thumbnails too
            thumbnailUrl = getProxiedUrl(thumbnailUrl);
          } else {
            // For direct mode, we'll handle image loading errors
            thumbnailUrl = thumbnailUrl;
          }

          // Determine media type and preview
          const previewHtml = getPreviewHtml(item, thumbnailUrl);

          // Format file size
          const fileSize = item.media_details && item.media_details.filesize
            ? formatFileSize(item.media_details.filesize)
            : 'Unknown';

          // Format date
          const date = new Date(item.date).toLocaleDateString();

          mediaItem.innerHTML = `
            <div class="media-preview">${previewHtml}</div>
            <div class="media-info">
              <h3 class="media-title">${item.title.rendered || 'Untitled'}</h3>
              <div class="media-meta">
                <span>Type: ${getMimeTypeLabel(item.mime_type)}</span>
                <span>Size: ${fileSize}</span>
                <span>Date: ${date}</span>
              </div>
              <div class="media-actions">
                <button class="preview-btn" data-id="${item.id}">Preview</button>
                <button class="download-btn" data-url="${sourceUrl}">Download</button>
              </div>
            </div>
          `;

          mediaGrid.appendChild(mediaItem);
        });

        // Add event listeners to buttons
        document.querySelectorAll('.preview-btn').forEach(btn => {
          btn.addEventListener('click', () => previewMedia(parseInt(btn.dataset.id)));
        });

        document.querySelectorAll('.download-btn').forEach(btn => {
          btn.addEventListener('click', () => downloadMedia(btn.dataset.url));
        });

        // Handle image loading errors
        document.querySelectorAll('.media-preview img').forEach(img => {
          img.onerror = function () {
            // Replace with a generic icon if the image fails to load
            const parent = this.parentElement;
            parent.innerHTML = `<div class="file-icon">🖼️</div>`;
          };
        });
      }

      // Render list view
      function renderListView() {
        listBody.innerHTML = '';

        if (state.mediaItems.length === 0) {
          const row = document.createElement('tr');
          row.innerHTML = '<td colspan="5" style="text-align: center; padding: 30px;">No media items found</td>';
          listBody.appendChild(row);
          return;
        }

        state.mediaItems.forEach(item => {
          const row = document.createElement('tr');

          // Format file size
          const fileSize = item.media_details && item.media_details.filesize
            ? formatFileSize(item.media_details.filesize)
            : 'Unknown';

          // Format date
          const date = new Date(item.date).toLocaleDateString();

          // Direct source URL for download
          const sourceUrl = item.source_url;

          // Get thumbnail for preview
          let thumbnailUrl = sourceUrl;
          if (item.media_details && item.media_details.sizes && item.media_details.sizes.thumbnail) {
            thumbnailUrl = item.media_details.sizes.thumbnail.source_url;
          }

          // Handle URL for cross-origin images
          if (state.proxyType !== 'noproxy') {
            // Use the proxy for thumbnails too
            thumbnailUrl = getProxiedUrl(thumbnailUrl);
          }

          // Determine preview HTML
          const previewHtml = getPreviewHtml(item, thumbnailUrl);

          const titleCell = document.createElement('td');
          titleCell.innerHTML = `
            <div class="list-preview">${previewHtml}</div>
            <span>${item.title.rendered || 'Untitled'}</span>
          `;

          row.appendChild(titleCell);

          // Add remaining cells
          row.innerHTML += `
            <td>${getMimeTypeLabel(item.mime_type)}</td>
            <td>${date}</td>
            <td>${fileSize}</td>
            <td>
              <button class="preview-btn" data-id="${item.id}">Preview</button>
              <button class="download-btn" data-url="${sourceUrl}">Download</button>
            </td>
          `;

          listBody.appendChild(row);
        });

        // Add event listeners to buttons
        document.querySelectorAll('.preview-btn').forEach(btn => {
          btn.addEventListener('click', () => previewMedia(parseInt(btn.dataset.id)));
        });

        document.querySelectorAll('.download-btn').forEach(btn => {
          btn.addEventListener('click', () => downloadMedia(btn.dataset.url));
        });

        // Handle image loading errors
        document.querySelectorAll('.list-preview img').forEach(img => {
          img.onerror = function () {
            // Replace with a generic icon if the image fails to load
            const parent = this.parentElement;
            parent.innerHTML = `<div class="file-icon" style="font-size: 24px;">🖼️</div>`;
          };
        });
      }

      // Preview media in modal
      // Preview media in modal
      function previewMedia(id) {
        const item = state.mediaItems.find(item => item.id === id);
        if (!item) return;

        // Direct source URL
        let sourceUrl = item.source_url;
        previewContainer.innerHTML = '';

        if (item.mime_type.startsWith('image/')) {
          const imgContainer = document.createElement('div');
          imgContainer.className = 'image-preview-container';
          imgContainer.style.width = '100%';
          imgContainer.style.height = '100%';
          imgContainer.style.display = 'flex';
          imgContainer.style.justifyContent = 'center';
          imgContainer.style.alignItems = 'center';

          const img = document.createElement('img');
          img.alt = item.title.rendered || 'Image';
          img.className = 'retry-image';
          img.style.maxWidth = '100%';
          img.style.maxHeight = '80vh';
          img.style.objectFit = 'contain';
          img.setAttribute('data-original-url', sourceUrl);

          // Placeholder while loading
          img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
          imgContainer.appendChild(img);
          previewContainer.appendChild(imgContainer);

          // Create a custom sequence with the user's selected proxy first
          const proxySequence = [state.proxyType];

          // Add other proxies to try
          ['allorigins', 'cors-anywhere', 'noproxy', 'sw-proxy'].forEach(proxy => {
            if (proxy !== state.proxyType && (proxy !== 'sw-proxy' || PROXY_URLS['sw-proxy'])) {
              proxySequence.push(proxy);
            }
          });

          // Start the retry sequence
          loadImageWithRetry(img, sourceUrl, proxySequence);
        } else if (item.mime_type.startsWith('video/')) {
          // Rest of the code remains the same
        }

        previewModal.style.display = 'flex';
      }

      function loadImageWithRetry(img, originalUrl, proxyTypes = null, attemptIndex = 0) {
        // Define proxy types to try in sequence
        const proxyTypesToTry = proxyTypes || ['allorigins', 'cors-anywhere', 'noproxy', 'sw-proxy'];

        // Stop if we've tried all proxies
        if (attemptIndex >= proxyTypesToTry.length) {
          img.onerror = null; // Stop retry cycle
          img.parentElement.innerHTML = '<div class="file-icon">🖼️</div>';
          console.log('All proxy attempts failed for:', originalUrl);
          return;
        }

        // Get current proxy to try
        const currentProxy = proxyTypesToTry[attemptIndex];

        // Create proxied URL based on the current proxy type
        let proxiedUrl;
        if (currentProxy === 'noproxy' || true) {
          proxiedUrl = originalUrl;
        } else if (currentProxy === 'allorigins') {
          proxiedUrl = PROXY_URLS.allorigins + encodeURIComponent(originalUrl);
        } else if (currentProxy === 'cors-anywhere') {
          proxiedUrl = PROXY_URLS['cors-anywhere'] + originalUrl;
        } else if (currentProxy === 'sw-proxy' && PROXY_URLS['sw-proxy']) {
          proxiedUrl = PROXY_URLS['sw-proxy'] + encodeURIComponent(originalUrl);
        } else {
          // Skip unavailable proxies
          loadImageWithRetry(img, originalUrl, proxyTypesToTry, attemptIndex + 1);
          return;
        }
        proxiedUrl = originalUrl;

        // Set up retry on error
        img.onerror = function () {
          console.log(`Proxy ${currentProxy} failed for ${originalUrl}, trying next...`);
          // Small delay before trying next proxy
          setTimeout(() => {
            loadImageWithRetry(img, originalUrl, proxyTypesToTry, attemptIndex + 1);
          }, 200);
        };

        img.onload = function () {
          // Remove loading indicator when image successfully loads
          img.style.backgroundImage = 'none';

          // If this is a modal preview image, adjust the modal container
          if (img.closest('.preview-content')) {
            const previewContent = img.closest('.preview-content');
            previewContent.style.width = 'auto';
            previewContent.style.height = 'auto';
          }
        };

        // Apply the URL and attempt to load
        img.src = proxiedUrl;
      }

      // Get preview HTML with retry logic for images
      function getPreviewHtml(item, thumbnailUrl) {
        if (item.mime_type.startsWith('image/')) {
          // For images, we'll create the element but load it with our retry mechanism
          return `<img data-original-url="${thumbnailUrl}" alt="${item.title.rendered || 'Image'}" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class="retry-image" />`;
        } else if (item.mime_type.startsWith('video/')) {
          return `<div class="file-icon">🎬</div>`;
        } else if (item.mime_type.startsWith('audio/')) {
          return `<div class="file-icon">🔊</div>`;
        } else if (item.mime_type.startsWith('application/pdf')) {
          return `<div class="file-icon">📄</div>`;
        } else {
          return `<div class="file-icon">📁</div>`;
        }
      }

      // Initialize retry loading for all images
      function initializeRetryImages() {
        // Get all images with retry-image class
        document.querySelectorAll('.retry-image').forEach(img => {
          const originalUrl = img.getAttribute('data-original-url');
          if (originalUrl) {
            // Create a custom sequence with the user's selected proxy first
            const proxySequence = [state.proxyType];

            // Add other proxies to try (excluding the one already chosen)
            ['allorigins', 'cors-anywhere', 'noproxy', 'sw-proxy'].forEach(proxy => {
              if (proxy !== state.proxyType && (proxy !== 'sw-proxy' || PROXY_URLS['sw-proxy'])) {
                proxySequence.push(proxy);
              }
            });

            // Start the retry sequence
            loadImageWithRetry(img, originalUrl, proxySequence);
          }
        });
      }


      // Close preview modal
      function closePreviewModal() {
        previewModal.style.display = 'none';
        previewContainer.innerHTML = '';
      }

      // Download media
      function downloadMedia(url) {
        // For direct downloads, we need to handle CORS restrictions
        if (state.proxyType === 'noproxy' || true) {
          // Open the URL in a new tab as a fallback
          window.open(url, '_blank');
        } else {
          // Use the proxy URL for download
          const proxyUrl = getProxiedUrl(url);

          // Create a temporary link to trigger the download
          fetch(proxyUrl)
            .then(response => response.blob())
            .then(blob => {
              // Extract filename from URL
              const filename = url.split('/').pop();

              // Create object URL
              const blobUrl = URL.createObjectURL(blob);

              // Create temporary link and click it
              const a = document.createElement('a');
              a.href = blobUrl;
              a.download = filename;
              document.body.appendChild(a);
              a.click();

              // Clean up
              setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(blobUrl);
              }, 100);
            })
            .catch(error => {
              console.error('Download error:', error);
              // Fallback to opening in new tab
              window.open(url, '_blank');
            });
        }
      }

      // Get preview HTML based on mime type
      function getPreviewHtml(item, thumbnailUrl) {
        // Always proxy the thumbnail URL when a proxy is selected
        const proxiedThumbnailUrl = state.proxyType !== 'noproxy' ?
          getProxiedUrl(thumbnailUrl) : thumbnailUrl;

        if (item.mime_type.startsWith('image/')) {
          return `<img src="${proxiedThumbnailUrl}" alt="${item.title.rendered || 'Image'}" onerror="this.parentElement.innerHTML='<div class=\\'file-icon\\'>🖼️</div>';" />`;
        } else if (item.mime_type.startsWith('video/')) {
          return `<div class="file-icon">🎬</div>`;
        } else if (item.mime_type.startsWith('audio/')) {
          return `<div class="file-icon">🔊</div>`;
        } else if (item.mime_type.startsWith('application/pdf')) {
          return `<div class="file-icon">📄</div>`;
        } else {
          return `<div class="file-icon">📁</div>`;
        }
      }


      // Get friendly label for mime type
      function getMimeTypeLabel(mimeType) {
        if (!mimeType) return 'Unknown';

        if (mimeType.startsWith('image/')) {
          return `Image (${mimeType.split('/')[1]})`;
        } else if (mimeType.startsWith('video/')) {
          return `Video (${mimeType.split('/')[1]})`;
        } else if (mimeType.startsWith('audio/')) {
          return `Audio (${mimeType.split('/')[1]})`;
        } else if (mimeType.startsWith('application/')) {
          const format = mimeType.split('/')[1];
          if (format === 'pdf') return 'PDF';
          if (format.includes('word')) return 'Word Document';
          if (format.includes('excel') || format.includes('spreadsheet')) return 'Spreadsheet';
          return `Document (${format})`;
        } else {
          return mimeType;
        }
      }

      // Format file size
      function formatFileSize(bytes) {
        if (!bytes || isNaN(bytes)) return 'Unknown';

        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let size = bytes;
        let unitIndex = 0;

        while (size >= 1024 && unitIndex < units.length - 1) {
          size /= 1024;
          unitIndex++;
        }

        return `${size.toFixed(1)} ${units[unitIndex]}`;
      }

      // Update search
      function updateSearch() {
        state.search = searchInput.value.trim();
        state.currentPage = 1;
        fetchMedia();
      }

      // Update filters
      function updateFilters() {
        state.mediaType = mediaTypeSelect.value;
        state.sortBy = sortBySelect.value;
        state.sortOrder = sortOrderSelect.value;
        state.currentPage = 1;
        fetchMedia();
      }

      // Switch view mode
      function switchView(mode) {
        state.viewMode = mode;

        if (mode === 'grid') {
          mediaGrid.style.display = 'grid';
          mediaList.style.display = 'none';
          gridViewBtn.classList.add('active-view');
          listViewBtn.classList.remove('active-view');
        } else {
          mediaGrid.style.display = 'none';
          mediaList.style.display = 'table';
          gridViewBtn.classList.remove('active-view');
          listViewBtn.classList.add('active-view');
        }

        renderMedia();
      }

      // Go to previous page
      function goToPreviousPage() {
        if (state.currentPage > 1) {
          state.currentPage--;
          fetchMedia();
        }
      }

      // Go to next page
      function goToNextPage() {
        if (state.currentPage < state.totalPages) {
          state.currentPage++;
          fetchMedia();
        }
      }

      // Update pagination controls
      function updatePagination() {
        prevPageBtn.disabled = state.currentPage <= 1;
        nextPageBtn.disabled = state.currentPage >= state.totalPages;
      }

      // Set loading state
      function setLoading(isLoading) {
        state.isLoading = isLoading;
        loader.style.display = isLoading ? 'inline-block' : 'none';
      }

      // Show error message
      function showError(message) {
        errorMessage.textContent = message;
        errorMessage.style.display = 'block';
      }

      // Hide error message
      function hideError() {
        errorMessage.style.display = 'none';
      }

      // Debounce function for search input
      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }

      // Service worker for CORS proxy
      function setupServiceWorker() {
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            // Register the service worker from a blob to avoid having to host it separately
            const swCode = `
              // In-browser CORS proxy service worker
              self.addEventListener('fetch', event => {
                const url = new URL(event.request.url);
                
                // Only intercept requests with the special prefix
                if (url.pathname.startsWith('/corsproxy/')) {
                  event.respondWith((async () => {
                    // Extract the target URL
                    const targetURL = url.pathname.slice('/corsproxy/'.length);
                    let decodedURL;
                    
                    try {
                      // Handle both encoded and "plain" URLs
                      decodedURL = decodeURIComponent(targetURL);
                    } catch (e) {
                      decodedURL = targetURL;
                    }
                    
                    // Ensure it's an absolute URL
                    if (!decodedURL.startsWith('http')) {
                      decodedURL = 'https://' + decodedURL;
                    }
                    
                    try {
                      // Clone the original request
                      const modifiedRequest = new Request(decodedURL, {
                        method: event.request.method,
                        headers: event.request.headers,
                        body: event.request.body,
                        mode: 'cors',
                        credentials: 'omit'
                      });
                      
                      // Fetch with modified request
                      const response = await fetch(modifiedRequest);
                      
                      // Clone the response and create a new one with CORS headers
                      const responseBody = await response.blob();
                      
                      return new Response(responseBody, {
                        status: response.status,
                        statusText: response.statusText,
                        headers: {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
                          'Content-Type': response.headers.get('Content-Type') || 'text/plain'
                        }
                      });
                    } catch (error) {
                      return new Response('Proxy error: ' + error.message, { status: 500 });
                    }
                  })());
                }
              });
              
              self.addEventListener('install', event => {
                self.skipWaiting();
              });
              
              self.addEventListener('activate', event => {
                event.waitUntil(clients.claim());
              });
            `;

            const blob = new Blob([swCode], { type: 'application/javascript' });
            const swURL = URL.createObjectURL(blob);

            navigator.serviceWorker.register(swURL, { scope: '/' })
              .then(registration => {
                console.log('Service Worker registered with scope:', registration.scope);
                // Add a built-in CORS proxy option
                const option = document.createElement('option');
                option.value = 'sw-proxy';
                option.textContent = 'Built-in CORS Proxy (Service Worker)';
                proxySelector.insertBefore(option, proxySelector.firstChild);

                // Add handler for service worker proxy
                PROXY_URLS['sw-proxy'] = '/corsproxy/';
              })
              .catch(error => {
                console.error('Service Worker registration failed:', error);
              });
          });
        }
      }

      // Try to set up the service worker for built-in CORS proxy (modern browsers only)
      try {
        setupServiceWorker();
      } catch (e) {
        console.log('Service worker setup failed:', e);
      }
    });
  </script>
  <footer class="version-footer">
    <hr>
    <p>WordPress Media Explorer v1.0.4</p>
  </footer>
</body>

</html>
